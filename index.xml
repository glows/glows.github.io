<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Glow's Blog</title><link>https://glows.github.io/</link><description>Recent content on Glow's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>glows</copyright><lastBuildDate>Wed, 04 Nov 2020 09:24:04 +0000</lastBuildDate><atom:link href="https://glows.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Checklist</title><link>https://glows.github.io/_posts/2020-11-04-docker-checklist/</link><pubDate>Wed, 04 Nov 2020 09:24:04 +0000</pubDate><guid>https://glows.github.io/_posts/2020-11-04-docker-checklist/</guid><description> [ x ] 创建 docker build -t &amp;lt;name&amp;gt; &amp;lt;dir&amp;gt; [ x ] 打包 添加 tag
docker tag &amp;lt;image name&amp;gt; &amp;lt;new image name:new tag&amp;gt; docker save -o &amp;lt;file name&amp;gt; &amp;lt;image name&amp;gt; [ x ] 发布 dokcer push or
docker load &amp;lt;image name</description></item><item><title>typescript学习</title><link>https://glows.github.io/_posts/2020-10-13-typescript%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 13 Oct 2020 11:34:25 +0000</pubDate><guid>https://glows.github.io/_posts/2020-10-13-typescript%E5%AD%A6%E4%B9%A0/</guid><description>类型断言 在文件packages/shared/src/index.ts中第22行至第26行
export const babelParserDefaultPlugins = [ &amp;lsquo;bigInt&amp;rsquo;, &amp;lsquo;optionalChaining&amp;rsquo;, &amp;lsquo;nullishCoalescingOperator&amp;rsquo; ] as const 上面代码中的as是类型断言之一，
它的作用就是断定babelParserDefaultPlugins是const类型。
第二种类型断言即尖括号的类型断言
let str = bar; 它的作用是断定bar的类型是string。
这两种的类型断言作用是一样的，区别只是写法上不同。
一般我们使用as后面跟的是一个数据类型比如string，number，any或interface
使用as const是标定此变量是只读的。
有些人会问不是已经使用了const定义变量了吗？此变量就是不能修改的呀！
其实const定义的变量只是不能修改它自身，如果它是引用类型的变量，比如数组，对象，我们是可以修改它的子项的。</description></item><item><title>sql 基本命令</title><link>https://glows.github.io/_posts/2020-10-12-sql-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 12 Oct 2020 14:22:08 +0000</pubDate><guid>https://glows.github.io/_posts/2020-10-12-sql-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</guid><description>1、显示数据库列表。 show databases; 2、显示库中的数据表： use mysql; show tables; 3、显示数据表的结构： describe 表名; 4、建库： create database 库名; 5、建表： use 库名； create table 表名 (字段设定列表)； 6、删库和删表: drop database 库名; drop table 表名； 7、将表中记录清空： delete from 表名; 8、显示表中的记录： select * from 表名
//&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
（1）选择使用某个数据库
use xxxdb;
(2)创建数据库
create database xxxdb;
MySQL Getting started: https://gist.github.com/hofmannsven/9164408</description></item><item><title>node 后端实践</title><link>https://glows.github.io/_posts/2020-02-14-node-%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 14 Sep 2020 18:33:21 +0000</pubDate><guid>https://glows.github.io/_posts/2020-02-14-node-%E5%90%8E%E7%AB%AF%E5%AE%9E%E8%B7%B5/</guid><description>Koa &amp;amp; Typescript (typeORM + mysql) requies:
Node.js：10.x 及以上 npm：6.x 及以上 Koa：2.x MySQL：推荐稳定的 5.7 版本及以上 TypeORM：0.2.x 确保 MySQL 数据库实例已在运行。</description></item><item><title>前端常用工具方法</title><link>https://glows.github.io/_posts/2020-08-27%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 27 Aug 2020 14:26:11 +0000</pubDate><guid>https://glows.github.io/_posts/2020-08-27%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</guid><description>storage.js
/** * 存储localStorage */ export const setStore = (name, content) =&amp;gt; { if (!name) return; if (typeof content !== &amp;#34;string&amp;#34;) { content = JSON.stringify(content); } window.localStorage.setItem(name, content); }; /** * 获取localStorage */ export const getStore = (name) =&amp;gt; { if (!name) return; return window.localStorage.getItem(name); }; /** * 删除localStorage */ export const removeStore = (name) =&amp;gt; { if (!name) return; window.localStorage.removeItem(name); }; RegUtils.js
const regCommon=/^[0-9A-Za-z\u4e00-\u9fa5_\-]+$/; const regEmail=/^[a-z0-9A-Z]+[- |a-z0-9A-Z._]+@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\.)+[a-z]{2,}$/; const regCode=/^[0-9A-Za-z]+$/; const regPhone=/^1(3|4|5|6|7|8|9)\d{9}$/; export function isCommonText(text:string) { // if(!</description></item><item><title>网页录音</title><link>https://glows.github.io/_posts/2020-8-19-%E7%BD%91%E9%A1%B5%E5%BD%95%E9%9F%B3/</link><pubDate>Wed, 19 Aug 2020 10:57:35 +0000</pubDate><guid>https://glows.github.io/_posts/2020-8-19-%E7%BD%91%E9%A1%B5%E5%BD%95%E9%9F%B3/</guid><description>var audioCtx = new AudioContext(); var source = audioCtx.createMediaStreamSource(stream);
或者参考第三方库Recorder, github: https://github.com/xiangyuecn/Recorder， recorderjs</description></item><item><title>WebSocket 使用</title><link>https://glows.github.io/_posts/2020-8-19-websocket-%E5%B0%81%E8%A3%85/</link><pubDate>Wed, 19 Aug 2020 10:03:07 +0000</pubDate><guid>https://glows.github.io/_posts/2020-8-19-websocket-%E5%B0%81%E8%A3%85/</guid><description>WebSocket 封装 WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。
WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。
WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。
let websock = null let messageCallback = null // callback message important !!!! let errorCallback = null let wsUrl = &amp;#39;&amp;#39; // 接收ws后端返回的数据 function websocketonmessage (e) { messageCallback(JSON.parse(e.data)) } /** * 发起websocket连接 * @param {Object} agentData 需要向后台传递的参数数据 */ function websocketSend (agentData) { // 加延迟是为了尽量让ws连接状态变为OPEN setTimeout(() =&amp;gt; { // 添加状态判断，当为OPEN时，发送消息 if (websock.readyState === websock.OPEN) { // websock.OPEN = 1 // 发给后端的数据需要字符串化 websock.</description></item><item><title>常见数据结构</title><link>https://glows.github.io/_posts/2020-4-15-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 15 Apr 2020 14:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/2020-4-15-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>回到最初，计算机科学
基础学科内容，比如：网络知识、数据结构算法 编程思想
时间复杂度
常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。
栈 栈是一种LIFO(Last-In-First-Out，后进先出)的 数据结构
class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } peek() { return this.stack[this.getCount() - 1] } getCount() { return this.stack.length } isEmpty() { return this.getCount() === 0 } } 队列 队列数据结构的访问 规则是FIFO(First-In-First-Out，先进先出)。
this.stack.push(item) this.stack.shift() //移除数组中的第一个项并返回该项 链表 单向链表
class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度 this.</description></item><item><title>React-Hooks 指南</title><link>https://glows.github.io/_posts/2020-2-12-%E5%AD%A6%E4%BC%9Areact-hooks/</link><pubDate>Wed, 12 Feb 2020 10:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/2020-2-12-%E5%AD%A6%E4%BC%9Areact-hooks/</guid><description>React Hooks 含义 为函数组件提供钩子以实现外部功能，如添加状态
React 默认提供的四个最常用的钩子 useState() //状态 useEffect() //函数副作用 useContext() useReducer() 更多的 Hook包括 useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue 自定义Hook useImperativeHandle Typescript中搭配useImperativeHandle 和 forwardRef使用
export interface MyInputHandles { focus(): void; } const MyInput: RefForwardingComponent&amp;lt;MyInputHandles, MyInputProps&amp;gt; = ( props, ref ) =&amp;gt; { const inputRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); useImperativeHandle(ref, () =&amp;gt; ({ focus: () =&amp;gt; { if (inputRef.current) { inputRef.current.focus(); } }, })); return &amp;lt;input {...props} ref={inputRef} /&amp;gt;; }; export default forwardRef(MyInput); 建议useImperativeHandle和forwardRef同时使用，减少暴露给父组件的属性，避免使用 ref 这样的命令式代码 import { useRef,forwardRef,MutableRefObject,useImperativeHandle,Ref} from &amp;ldquo;react&amp;rdquo;;</description></item><item><title>Reactjs笔记</title><link>https://glows.github.io/_posts/reactjs%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 29 Jan 2019 14:30:41 +0000</pubDate><guid>https://glows.github.io/_posts/reactjs%E7%AC%94%E8%AE%B0/</guid><description>umiJs + antd_mobile + dvaJs 多类名及动态加载样式方法
覆盖组件样式 方法很简单，有两点需要注意：
引入的 antd 组件类名没有被 CSS Modules 转化，所以被覆盖的类名 .ant-select-selection 必须放到 :global 中。
因为上一条的关系，覆盖是全局性的。为了防止对其他 Select 组件造成影响，所以需要包裹额外的 className 限制样式的生效范围。 e.g.
.customSelect { :global { .ant-select-selection { max-height: 51px; overflow: auto; } } } model：模型
模型通常认为是视图(view)的内核，模型就是指视图的数据 // ES7新标准:装饰器（Decorator） @connect(state =&amp;gt; ({ user: state.user, }))
// 如果您不喜欢ES7装饰器，那好办，我就帮您写一个不用的 export default connect(state =&amp;gt; ({ user: state.user, }))(User);
dva的model 注意点： reducers 命名需正确，注意加s effects</description></item><item><title>函数式编程</title><link>https://glows.github.io/_posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8Bos/</link><pubDate>Tue, 29 Jan 2019 14:30:41 +0000</pubDate><guid>https://glows.github.io/_posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8Bos/</guid><description>与面向对象的区别 与面向对象方法将问题分解成多组&amp;quot;名词&amp;quot;或对象不同，函数式方法将相同的问题分解成多组&amp;quot;动词&amp;quot;或者函数。
与面向对象类似的是，函数式编程也通过&amp;quot;粘结&amp;quot;或&amp;quot;组合&amp;quot;其他函数的方式构建更大的函数，以实现更抽象的行为。
函数式：通过把功能拆解成一个个小函数组件，再用函数讲各个组件结合完成需求。
多种JS编程方式 命令式编程
通过详细描述行为的编程方式
基于原型的对象编程
基于原型对象和实例的编程方式
元编程
基于模型数据进行编写和操作的编程方式
函数式编程
基于函数进行操作的编程方式
Applicative编程函数作为参数的编程方式 集合中心编程对数据进行操作，包括对象和数组的编程方式
其他编程：
面向类型
事件编程</description></item><item><title>解决VSCode保存时自动格式化</title><link>https://glows.github.io/_posts/%E8%A7%A3%E5%86%B3vscode%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/</link><pubDate>Wed, 15 Aug 2018 14:57:24 +0000</pubDate><guid>https://glows.github.io/_posts/%E8%A7%A3%E5%86%B3vscode%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid><description>把JS-CS-HTML Formatter这个插件禁用</description></item><item><title>理解CSS属性：touch-action</title><link>https://glows.github.io/_posts/%E7%90%86%E8%A7%A3css%E5%B1%9E%E6%80%A7touch-action/</link><pubDate>Thu, 09 Aug 2018 11:15:23 +0000</pubDate><guid>https://glows.github.io/_posts/%E7%90%86%E8%A7%A3css%E5%B1%9E%E6%80%A7touch-action/</guid><description>CSS属性 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。
/* Keyword values */ touch-action: auto; touch-action: none; touch-action: pan-x; touch-action: pan-left; touch-action: pan-right; touch-action: pan-y; touch-action: pan-up; touch-action: pan-down; touch-action: pinch-zoom; touch-action: manipulation; /* Global values */ touch-action: inherit; touch-action: initial; touch-action: unset; 初始值 auto 适用元素 all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups 是否是继承属性 否 适用媒体 visual 计算值 as specified Animation type discrete 正规顺序 the unique non-ambiguous order defined by the formal grammar 默认情况下，平移（滚动）和缩放手势由浏览器专门处理。 使用 Pointer_events 的应用程序将在浏览器开始处理触摸手势时收到一个 pointercancel 事件。 通过明确指定浏览器应该处理哪些手势，应用程序可以在 pointermove 和 pointerup 监听器中为其余的手势提供自己的行为。 使用 Touch_events 的应用程序通过调用 preventDefault() 禁用浏览器处理手势，但也应使用触摸操作确保浏览器在调用任何事件侦听器之前，了解应用程序的意图。</description></item><item><title>Vue改变对象的属性值视图不更新的问题</title><link>https://glows.github.io/_posts/vue%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 25 Jul 2018 10:37:01 +0000</pubDate><guid>https://glows.github.io/_posts/vue%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E8%A7%86%E5%9B%BE%E4%B8%8D%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>最近项目在使用vue，遇到几次修改了对象的属性后，页面并不重新渲染，场景如下：
查看官方文档后了解到：受到javascript的限制，Vue不能检测到对象属性的添加或删除。因为Vue利用的是Object的defineProperty()方法，在初始化实列时将属性转为getter/setter，所以属性必须在data对象上才能让vue转换它。 后通过查找资料修改为使用$set来设定修改值，js如下： 我们可以使用 Vue.set(object, key, value) 方法将响应属性添加到数组里的对象上。 所以将
this.stuList[index].checked=true; 改成
Vue.set(this.stuList[index], &amp;#39;checked&amp;#39;, true); 还可以使用 vm.$set实例方法，这也是全局 Vue.set方法的别名:
this.$set(this.stuList[index],&amp;#39;checked&amp;#39;,true); 但是依然没有起作用，
再从查找的资料才知道是数据层次太多，没有触发render函数进行自动更新，需手动调用，调用方式如下:
this.$forceUpdate(); 完整代码如下：
handleCheck(index) { this.$nextTick(() =&amp;gt; { this.$forceUpdate(); this.$set(this.stuList[index],&amp;#39;checked&amp;#39;,true); }) },</description></item><item><title>Python 数据类型</title><link>https://glows.github.io/_posts/python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Tue, 24 Jul 2018 16:07:24 +0000</pubDate><guid>https://glows.github.io/_posts/python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>Python 中的每个值都有一个数据类型。 在 Python 编程中，一切（万物）皆对象，如同在Unix上一切皆文件。数据类型实际上是类，变量是这些类的实例（对象）。 Python提供多种数据类型来存放数据项集合，主要包括序列（列表list和元组tuple），映射（如字典dict），集合（set）</description></item><item><title>linux查看系统信息的一些命令</title><link>https://glows.github.io/_posts/linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</link><pubDate>Tue, 24 Jul 2018 09:51:48 +0000</pubDate><guid>https://glows.github.io/_posts/linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</guid><description>Linux查看系统信息的一些命令及查看已安装软件包的命令（转) 文章分类:操作系统
系统
# uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # hostname # 查看计算机名 # lspci -tv # 列出所有PCI设备 # lsusb -tv # 列出所有USB设备 # lsmod # 列出加载的内核模块 # env # 查看环境变量 资源
# free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh &amp;lt;目录名&amp;gt; # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载 磁盘和分区</description></item><item><title>React与Redux</title><link>https://glows.github.io/_posts/react%E4%B8%8Eredux/</link><pubDate>Thu, 28 Jun 2018 14:09:12 +0000</pubDate><guid>https://glows.github.io/_posts/react%E4%B8%8Eredux/</guid><description>React与Redux Redux 的设计思想很简单，就两句话。 （1）Web 应用是一个状态机，视图与状态是一一对应的。 （2）所有的状态，保存在一个对象里面。</description></item><item><title>vue问题收集</title><link>https://glows.github.io/_posts/vue%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</link><pubDate>Wed, 20 Jun 2018 11:43:39 +0000</pubDate><guid>https://glows.github.io/_posts/vue%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</guid><description>1、Why is Vue.js Chrome Devtools not detecting Vue.js? 打开本地文件vueDevtools 无法检测到Vue.js, 需要打开Chrome vueDevtools配置允许本地文件访问 One alternative is to set up a local web server, as the OP already stated. The other - which IMHO is faster and less harassing - is letting the extension have access to file URLs, which is disabled by default.
Simply go to chrome://extensions and leave the &amp;ldquo;Allow access to file URLs&amp;rdquo; box checked for Vue.js devtools.</description></item><item><title>docker使用指南</title><link>https://glows.github.io/_posts/docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Tue, 29 May 2018 14:03:46 +0000</pubDate><guid>https://glows.github.io/_posts/docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>命令提示：
docker --version Docker version docker-compose --version docker-machine --version docker ps docker version docker info 首先 Windows 下启动docker machine(更多命令 docker-machine -h), 使用dokcer-machine ls查看已安装的机器
docker-machine start [machine name] 执行
docker-machine env [machine name] 运行成功，会出现如下的代码：
@FOR /f &amp;quot;tokens=*&amp;quot; %i IN ('docker-machine env box') DO @%i 按提示拷贝在shell中执行
下一步，输入docker version便会显示有Client和Server,如下
Client: Version: 17.10.0-ce API version: 1.33 Go version: go1.8.3 Git commit: f4ffd25 Built: Tue Oct 17 19:00:02 2017 OS/Arch: windows/amd64 Server: Version: 17.12.0-ce API version: 1.</description></item><item><title>JavaScript模块规范 --- Commonjs、AMD、CMD、es6 modules</title><link>https://glows.github.io/_posts/javascript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-commonjsamdcmdes6-modules/</link><pubDate>Thu, 24 May 2018 10:37:24 +0000</pubDate><guid>https://glows.github.io/_posts/javascript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-commonjsamdcmdes6-modules/</guid><description>&lt;p>关键词: import require javascript module&lt;/p></description></item><item><title>搭建gogs遇到的问题</title><link>https://glows.github.io/_posts/%E6%90%AD%E5%BB%BAgogs%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 21 May 2018 10:25:55 +0000</pubDate><guid>https://glows.github.io/_posts/%E6%90%AD%E5%BB%BAgogs%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;p>关键词：git gogs&lt;/p></description></item><item><title>about</title><link>https://glows.github.io/about/</link><pubDate>Thu, 17 May 2018 16:14:08 +0000</pubDate><guid>https://glows.github.io/about/</guid><description>My languages HTML/CSS/Some JS
Bash
Learning C++
Learning python
English and Japanese
I use&amp;hellip; MacOS
Git
Vim or Vscode
Emacs
GitLab/Hub
Thanks!
Biography Server-Side NodeJS &amp;amp; Front-end Developer. Currently working as a Fullstack Engineer in ShenZhen. In my spare time I enjoy playing video games, or working on various side projects.
Who controls the memes, controls the Universe</description></item><item><title>categories</title><link>https://glows.github.io/categories/</link><pubDate>Thu, 17 May 2018 15:33:56 +0000</pubDate><guid>https://glows.github.io/categories/</guid><description/></item><item><title>reactjs&amp;redux一些问题</title><link>https://glows.github.io/_posts/reactjsredux%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 17 May 2018 11:12:16 +0000</pubDate><guid>https://glows.github.io/_posts/reactjsredux%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="reactjsredux一些问题">reactjs&amp;amp;redux一些问题&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>缩进貌似会引起编译出错,遇到一次,不明觉厉;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>html文本中不能有&amp;lt;,&amp;gt;这种字符,如果需要用,需要用html编码替代;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的React.createClass组件,命名时首字母要大写,不然会识别为一个标签而不是组件;&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>JS函数式编程记录</title><link>https://glows.github.io/_posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 11 May 2018 17:15:06 +0000</pubDate><guid>https://glows.github.io/_posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95/</guid><description>JS函数式编程记录 第一部分 组合 组合 var compose = function(f, g) { return function(x) { return f(g(x)); }; }; var toUpperCase = function(x) { return x.toUpperCase(); }; var exclaim = function(x) { return x + &amp;#39;!&amp;#39;; }; var shout = compose(exclaim, toUpperCase); let result = shout(&amp;#34;send in the clowns&amp;#34;); 实例应用 ./index.html
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;flickr&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.11/require.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;./flickr.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 实现声明式代码， 而非命令式。compose 表达式只是简单地指出了这样一个事实： 两个行为的组合。 这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。</description></item><item><title>柯里化函数与多个连续箭头函数</title><link>https://glows.github.io/_posts/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 10 May 2018 15:27:36 +0000</pubDate><guid>https://glows.github.io/_posts/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</guid><description>柯里化函数与多个连续箭头函数 柯里化 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化， 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数， 并且返回接受余下的参数而且返回结果的新函数的技术。 这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的， 尽管它是Moses Schönfinkel和戈特洛布·弗雷格发明的。
说的明白一点就是，给函数传递一部分参数，让它返回一个函数去处理其他参数，举个例子，求三个数之和：
let addOne = function add(x) { return function(y) { return function(z) { return x + y + z } } } let one = addOne(3) // 函数工厂 : 创造函数的工厂 创建一个one 函数 console.log(one) //ƒ (y) {return function (z) {return x + y + z}} let two = one(4) console.log(two) //ƒ (z) {return x + y + z} let three = two(5) console.log(three) //12 多个连续箭头函数 function add(a) { return function(b) { return a + b } } var add3 = add(3) add3(4) === 3 + 4 //true add 函数 在 es6 里的写法等价为</description></item><item><title>ECMAScript(ES6)新语法</title><link>https://glows.github.io/_posts/ecmascript-es6-%E6%96%B0%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 07 May 2018 11:50:10 +0000</pubDate><guid>https://glows.github.io/_posts/ecmascript-es6-%E6%96%B0%E8%AF%AD%E6%B3%95/</guid><description>ECMAScript(ES6)新语法 01.课程介绍-ECMAScript 新功能
02.块的作用域-let
03.恒量-const
04.解构数组-Array Destructuring
05.解构对象-Object Destructuring
06.模版字符串-Template Strings
07.带标签的模版字符串-Tagged Templates
08.判断字符串里是否包含其他字符串
09.默认参数 - Default Parameter Values
10.展开操作符-Spread
11.剩余操作符Rest
12.解构参数 - Destructured Parameters
13.函数的名字-name属性
14.箭头函数-Arrow Fuctions
() =&amp;gt; { } 15.对象表达式
16.对象属性名
const obj = { get foo() {}, set foo(x) {} }; obj.foo.name // TypeError: Cannot read property &amp;#39;name&amp;#39; of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, &amp;#39;foo&amp;#39;); descriptor.get.name // &amp;#34;get foo&amp;#34; descriptor.set.name // &amp;#34;set foo&amp;#34; 17.对比两个值是否相等-Object.is()
+0 === -0 //true NaN === NaN // false Object.</description></item><item><title>React.js 记录</title><link>https://glows.github.io/_posts/react-js-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 04 May 2018 11:34:48 +0000</pubDate><guid>https://glows.github.io/_posts/react-js-%E8%AE%B0%E5%BD%95/</guid><description>React.js 记录 概要 用了一段时间的 Reactjs，其实大部分的框架原理和 Vuejs 都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JS 中使用 JSX 手动的来创建 DOM。
开始一个新的 Reactjs 项目，我们通过自动化的脚手架创建工具 create-react-app 来创建一个初始化的 Reactjs 工程。
Reactjs 本身通过计算 Virtual DOM 之间的差异（Diff）来更新 UI 组件。每当 props 或者 state 改变时，Reactjs 会重新计算生成一个 Virtual DOM 对象，并且通过比较两个 VM 对象之间的差异来找出数据改变引起对应在 UI 上的差异，最后采用最小的成本来更新 UI。 在纯函数组件（同样的数据对应同样的 UI）下，对于相同的 props 和 state，其对应的 UI 显示应该是相同的。因此，当传递给组件的 props 或者 state 的改变与之前相同时，Reactjs 可以完全省略掉此时对组件 VM 的 Diff 计算，这在某种程度上可以提高 Reactjs 组件的渲染性能。为此，Reactjs 为我们提供了扩展的插件（Addon）“PureRenderMixin” 来解决这个问题。
React是非常灵活的，但它也有一个严格的规则： 所有的React组件必须像纯函数那样使用它们的props。
组件通讯 当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中的状态数据就能够更方便地交流共享了。</description></item><item><title>笔记之django &amp; vuejs 构建web项目</title><link>https://glows.github.io/_posts/%E7%AC%94%E8%AE%B0%E4%B9%8Bdjango-vuejs-%E6%9E%84%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</link><pubDate>Sat, 28 Apr 2018 14:22:34 +0000</pubDate><guid>https://glows.github.io/_posts/%E7%AC%94%E8%AE%B0%E4%B9%8Bdjango-vuejs-%E6%9E%84%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</guid><description>笔记之django &amp;amp; vuejs 构建web项目 一、 背景 在工作中我们经常须要构件一些基于web的项目，例如内部测试平台、运维系统等。本篇主要介绍如何使用后端Django + 前端Vue.js的技术栈快速地搭建起一套web项目的框架。
为什么使用Django和Vue.js?
Django是Python体系下最成熟的web框架之一，由于Python语言的易用性和受众面广，Django框架也因其能够快速开发网站应用的特性成为了中小型网站开发框架首选。且Django具备的数据分析( Pandas )、任务队列( Celery )、Restful API( Django REST framework )、ORM(类似java的hibernate)等一众功能都使得用户在面对任何建站需求时都能够得心应手。
Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js同样支持双向绑定、mustache标签语法等特性，并提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。
本篇使用Vue.js作为前端框架，代替Django本身较为孱弱的模板引擎，Django则作为服务端提供api接口，使得前后端实现完全分离，更适合单页应用的开发构建。</description></item><item><title>vue 组件通信</title><link>https://glows.github.io/_posts/vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</link><pubDate>Thu, 12 Apr 2018 11:35:44 +0000</pubDate><guid>https://glows.github.io/_posts/vue-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</guid><description>在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。 父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。 父组件通过 prop 给子组件下发数据:
Vue.component(&amp;#39;child&amp;#39;, { // 在 JavaScript 中使用 camelCase props: [&amp;#39;myMessage&amp;#39;], template: &amp;#39;&amp;lt;span&amp;gt;{{ myMessage }}&amp;lt;/span&amp;gt;&amp;#39; }) &amp;lt;!-- 在 HTML 中使用 kebab-case --&amp;gt; &amp;lt;child my-message=&amp;#34;hello!&amp;#34;&amp;gt;&amp;lt;/child&amp;gt; 子组件通过事件给父组件发送消息:
&amp;lt;div id=&amp;#34;message-event-example&amp;#34; class=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;p v-for=&amp;#34;msg in messages&amp;#34;&amp;gt;{{ msg }}&amp;lt;/p&amp;gt; &amp;lt;button-message v-on:message=&amp;#34;handleMessage&amp;#34;&amp;gt;&amp;lt;/button-message&amp;gt; &amp;lt;!-- 使用 $on(eventName) 监听事件 --&amp;gt; &amp;lt;/div&amp;gt; Vue.component(&amp;#39;button-message&amp;#39;, { template: `&amp;lt;div&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;message&amp;#34; /&amp;gt; &amp;lt;button v-on:click=&amp;#34;handleSendMessage&amp;#34;&amp;gt;Send&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;`, data: function () { return { message: &amp;#39;test message&amp;#39; } }, methods: { handleSendMessage: function () { this.</description></item><item><title>wepy框架开发小程序</title><link>https://glows.github.io/_posts/wepy%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link><pubDate>Thu, 01 Mar 2018 15:55:38 +0000</pubDate><guid>https://glows.github.io/_posts/wepy%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid><description>wepy 尝试使用wepy.request 可以发起请求但是获取不到response 值？ 答: 需要 promise 化 当前内置两个中间件：
requestfix: 修复小程序请求并发问题。 promisify：使用wepy.xxx的方式请求小程序原生API都将Promise化。
使用方法如下:
this.use(&amp;lsquo;requestfix&amp;rsquo;); this.use(&amp;lsquo;promisify&amp;rsquo;);
参考 [https://github.com/Tencent/wepy/wiki/wepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Promise]</description></item><item><title>看Neflix和YouTube TV教程</title><link>https://glows.github.io/_posts/%E7%9C%8Bneflix%E5%92%8Cyoutube-tv%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 26 Feb 2018 09:44:31 +0000</pubDate><guid>https://glows.github.io/_posts/%E7%9C%8Bneflix%E5%92%8Cyoutube-tv%E6%95%99%E7%A8%8B/</guid><description/></item><item><title>new year,new idea</title><link>https://glows.github.io/_posts/new-year-new-idea/</link><pubDate>Sun, 25 Feb 2018 09:39:27 +0000</pubDate><guid>https://glows.github.io/_posts/new-year-new-idea/</guid><description/></item><item><title>小程序开发记录</title><link>https://glows.github.io/_posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/</link><pubDate>Tue, 06 Feb 2018 10:38:39 +0000</pubDate><guid>https://glows.github.io/_posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/</guid><description>小程序开发记录 例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式(例如 React, Vue)，提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。 小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。
不支持dom操作 小程序脚本内不能使用window,document对象，所以无法操作dom。如果想操作节点，可用wx.createSelectorQuery()
另外数据驱动的开发模式，跟Vue相同，只是写法换了（vue: v-if，小程序: wx:if）
rpx布局 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
设计师做设计图以iPhone6作为设计稿基准就可以，基本上可以用rpx替换px，不过在一些表单或者提示页面，使用设计稿上的rpx会让小屏幕手机看着尺寸略小，提示页面可参照weui用px来实现
路由层级 wx.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面
wx.redirctTo(OBJECT) 关闭当前页面，跳转到应用内的某个页面
wx.switchTab(OBJECT) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
wx.reLaunch(OBJECT) 关闭所有页面，打开到应用内的某个页面
小程序只能同时打开打开5个页面，当打开5个页面后，wx.navigateTo不能正常打开新页面，请避免多层级的交互方式，或者使用wx.redirctTo重定向
tabBar底部导航栏 tabBar是一个数组。配置最少2个，最多5个，tab数组按顺序排序
页面滚动到顶部 基础库1.4.0支持
wx.pageScrollTo({ scrollTop: 0 //滚动到页面的目标位置（单位px） }) 图片资源，CSS中的背景图片 CSS中无法使用本地资源(开发目录中)的图片作为background-image。可以使用网络图片资源，或base64，或者使用image标签。tabBar的icon资源可使用本地资源
unionid与openid的区别 每个用户在每个小程序里面都有唯一的openid，如果想在多个公众号，小程序里面共享用户信息，统一识别该用户，则需要用到unionid。为了获取uniond则需要注册微信开放平台，将需要共享的小程序，公众号进行绑定（不超过10个，超过10个还要申请认证称为第三发平台）。
textarea在滚动页面中的bug textarea,map等组件是由客户端创建的原生组件，它的层级是最高的。如果有遇到定位元素的话。永远在最上面，盖不住。</description></item><item><title>webpack初探</title><link>https://glows.github.io/_posts/webpack%E5%88%9D%E6%8E%A2/</link><pubDate>Thu, 01 Feb 2018 14:22:34 +0000</pubDate><guid>https://glows.github.io/_posts/webpack%E5%88%9D%E6%8E%A2/</guid><description>基本设置 入口文件
多入口
设置Hot Module Replacement(HMR) 热模块替换 热加载
代码拆分
chunk 块 by Route 节省用户带宽
This “Webpack Composition” technique was taken from Webpack Academy
BONUS 红利
webpack-bundle-analyzer</description></item><item><title>Javascript基础数据结构</title><link>https://glows.github.io/_posts/javascript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 30 Jan 2018 10:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/javascript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>数据结构和类型 JavaScript语言可以识别下面 7 种不同类型的值：
六种 原型 数据类型: Boolean. 布尔值，true 和 false. null. 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。 undefined. 变量未定义时的属性。 Number. 表示数字，例如： 42 或者 3.14159。 String. 表示字符串，例如：&amp;ldquo;Howdy&amp;rdquo; Symbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。 以及 Object 对象 仅凭这些为数不多的数据类型，你就可以在你的应用程序中执行有用的功能。
Objects 和 functions 是本语言的其他两个基本要素。你可以将对象视为存放值的命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。</description></item><item><title>开发中遇到的问题记录</title><link>https://glows.github.io/_posts/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 22 Jan 2018 15:12:38 +0000</pubDate><guid>https://glows.github.io/_posts/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>开发中遇到的问题记录 js去重(基本数组 与 对象那个数组) var unique = {}; obarr = [ {name: &amp;#39;sdsd&amp;#39;,key: &amp;#39;zc&amp;#39;} ] obarr.forEach(function(gpa) { unique[JSON.stringify(gpa)] = gpa }); obarr = Object.keys(unique).map(function(u) { return JSON.parse(u) }); POST application/json 适用于传递多层的json 本来以为自己写了那么多post请求，ajax已经难不住了呢， 结果现实无比的残酷， 后台换成了java，发多层级的json，后台就取不到了， 虽然到最后还是配置正确了，。。记录下来，引以为戒，
axios.post(&amp;#34;POST&amp;#34;, &amp;#34;/URL&amp;#34;, this.state.datas, {headers: {&amp;#34;Content-Type&amp;#34;: &amp;#34;application/json&amp;#34;}}) .then( res =&amp;gt; { console.log(res.data) }) .catch(err =&amp;gt; { console.log(err) }) // 来一个原生版的 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.</description></item><item><title>Vuejs过渡动效(赋设计以生命)</title><link>https://glows.github.io/_posts/vuejs%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88-%E8%B5%8B%E8%AE%BE%E8%AE%A1%E4%BB%A5%E7%94%9F%E5%91%BD/</link><pubDate>Thu, 18 Jan 2018 10:51:19 +0000</pubDate><guid>https://glows.github.io/_posts/vuejs%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88-%E8%B5%8B%E8%AE%BE%E8%AE%A1%E4%BB%A5%E7%94%9F%E5%91%BD/</guid><description>一个好的交互应该是顺畅的、礼貌的、理智的
Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 包括以下工具：
在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 这里是一个典型的例子：
&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;button v-on:click=&amp;#34;show = !show&amp;#34;&amp;gt; Toggle &amp;lt;/button&amp;gt; &amp;lt;transition name=&amp;#34;fade&amp;#34;&amp;gt; &amp;lt;p v-if=&amp;#34;show&amp;#34;&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;/transition&amp;gt; &amp;lt;/div&amp;gt; new Vue({ el: &amp;#39;#demo&amp;#39;, data: { show: true } }) .fade-enter-active, .fade-leave-active { transition: opacity .5s; } .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } 过渡的类名 下面这段对理解比较重要 在进入/离开的过渡中，会有 6 个 class 切换。</description></item><item><title>web development</title><link>https://glows.github.io/_posts/web-development/</link><pubDate>Thu, 18 Jan 2018 10:51:19 +0000</pubDate><guid>https://glows.github.io/_posts/web-development/</guid><description>Web Designer / Basic Front end Dev  Build simple websites &amp;amp; UIs
PSD / AI -&amp;gt; HTML / CSS
Some dynamic UI with JavaScript
Choose to be a freelancer or a very entry level position
HTML / CSS Frameworks [Choose One]
Twitter Bootstrap 4 General framework, most popular
Materialize CSS Primarily a UI/UX framework
Bulma Easy to learn syntax, No JS Zurb Foundation Alternative to Bootstrap Skeleton VERY light boilerplate</description></item><item><title>瓦·斯皮瓦克：如何构建全球智能</title><link>https://glows.github.io/_posts/%E7%93%A6%E6%96%AF%E7%9A%AE%E7%93%A6%E5%85%8B%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%85%A8%E7%90%83%E6%99%BA%E8%83%BD/</link><pubDate>Wed, 10 Jan 2018 17:21:00 +0000</pubDate><guid>https://glows.github.io/_posts/%E7%93%A6%E6%96%AF%E7%9A%AE%E7%93%A6%E5%85%8B%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%85%A8%E7%90%83%E6%99%BA%E8%83%BD/</guid><description>(转载)诺瓦·斯皮瓦克：如何构建全球智能 凯文·凯利（Kevin Kelly）最近又写了一篇关于全球超个体存在证据的绝妙文章( http://www.kk.org/thetechnium/archives/2008/10/evidence_of_a_g.php )。对于正处于发展当中的这个文化基因理论来说，这又是一个有益的贡献。
我同意凯文（Kevin Kelly）所说的我们正处于第三阶段的观点。不过我与他的想法有一个重要不同，我认为超个体不仅仅是由机器组成，它同样也由人构成。 （请注意，我建议将“统一的机器体系”简称为“统一体”，这便于书写且听起来也很酷）
今天，人类仍就是组成这个统一体处理单元的主体。每个人类的神经系统都包含了数以十亿计的处理单元，而地球上又有数十亿的人类。这可是相当多的处理单元了。
然而，雷·库兹维尔（Ray Kurzweil）认为处理单元的平衡已经迅速的转向了更受欢迎的机器，也许在随后的半个世纪里，机器处理单元的数目就会超过或至少在计算速度上超过所有人脑处理单元总和，可能还会超过数倍。
在赞同Ray认为机器智能很快将超越人类智能观点的同时，我对库兹维尔（Ray Kurzweil）列出的时间表表示怀疑，特别是在得知最近有研究表明神经细胞内的微管系统中存在量子级别计算的迹象之后。如果人脑在微管级别的系统中存在计算行为的话，那么人脑中的处理单元数目可能将比现在预计的多出许多个数量级了。不过这个研究结果还有待确认。反对这项研究结果的人称人脑在经典物理层面上能够被模拟，而在这一层面上，量子级别的计算也不需要激发即可进行。我在此明确声明，我不是说人脑就是一台量子计算机，我说的只是有证据表明人脑中进行着量子级别或者接近量子级别的计算过程。量子效应对于人脑进行的工作是否有任何可衡量的影响并不是在本文讨论范围内，我们讨论的仅仅是微管系统是不是人脑中进行处理的最基本单位。如果是，那么人脑中就有比以前预想得多的处理单元。
另一点值得注意的就是人脑大部分计算过程不是发生在神经元细胞中，而是发生在突触的间隙之间。计算过程也更多的是通过化学反应而非电位变化。突触比神经元细胞多得多，突触之间进行的计算过程也比神经元传导进行得更快，其过程实现也更充分。化学层面的计算过程所引起的变化也确实比在神经元细胞中进行小上几个数量级。人脑进行计算过程的层次也比我们之前所想得要深。
话说回来，人脑进行计算的方式仍未知。我们对此有多种不相伯仲的假想，但是至今还没有最终的答案，不管前面提到的迹象表明了什么，我都认为人脑中的计算过程比我们现在想的更精细。
不管怎样，我和库兹维尔（Ray Kurzweil）都同意至少在这个星球上，人工制造的电脑数目将超过天然的人脑，这只是个时间问题。在我看来，实现这个过程要花的时间可能比库兹维尔（Ray Kurzweil）认为的要长一点：最晚可能会在100-200年以后实现吧。
在这个课题上，我想的另一些东西可能会在我的作品中引发争议。我不认为我们所说的“思感”可以被人工制造出来。人表现出来思感，但是我们现在都不清楚“思感”意味着什么。无可否认，我们都有过“思感”的经验，这种经验是神秘的，至少到目前为止没人能够让软件程序或者硬件装置看起来具备思感。事实上，我们甚至不知道如何验证“思感”的存在。比如那个备受追捧的图灵测验测试不了思感，它测试的只是类似于人的智慧。还没有哪个测试可以检验思感。对我们来说，开发出一种这样的测试可能是一项重要而又有趣的工作。
从我自身的观点来看，思感可能和空间、时间、能量一样对于宇宙本质认识的理解有着根本性帮助。我们不知道空间、时间和能量到底是什么，也不能实际地测量它们。我们所有测量空间、时间以及能量的方法都是间接的——通过测量其他事物来显示空间、时间和能量存在。空间、时间和能量的存在通过它们在我们可以测量的东西上产生影响来体现。同样的方法用于思感也同样有效。问题就是，怎么测量思感对事物所产生的影响？其中一个方法可能就是双缝实验了，这个试验会显示出观察的行为导致量子波函数崩溃的结果。还有其他什么我们能采用的影响结果来作为思感存在的证据吗？
我最近在想思感和我们所处宇宙的本质到底有多大的联系。如果思感是宇宙本质之一，那么我们就无法人为地制造它。就像我们从来都不能制造空间、时间和能量一样，因为它们都是宇宙的本质。
如果这是事实的话，那么我们就不可能制造思感。我们所能做的最多也就是引导已经是宇宙本质的思感。事实上，这可能就是人类神经系统所做的工作：它引导思感，这个过程大部分通过电子回路引导电流来实现。软件程序不大可能获得思感是因为他们离宇宙的本质太远。人工智能（AI）程序中认知的高水平显示和其对宇宙物理本质的量子级别演算过程（这个过程可能会具备思感）之间没有或仅有一点点联系。这不同于人的神经系统，在人的神经系统里，基本计算因素和所有认知行为都与宇宙本质直接联系在一起。这至少为思感（软件）、人脑（某种虚拟机器）和量子场（实际的硬件）之间产生双向反馈提供了必要的条件。
这也是我最近一直在问我自己的一个问题，思感与物理本质到底有什么联系？更进一步，思感对于我们认识的智能到底有多大的影响？如果思感对于智能很重要，那么人工智能也就不大可能只通过软件来实现，这可能得需要思感，而思感反过来又需要一个不同的计算系统来支持，这个系统与宇宙的量子物理基联系更紧密（通过双向反馈）。
这一切对我来说意味着人类可能在统一体——统一的机器体系这个新兴的全球超个体——中组成一个无可取代的重要部分。特别是现在，人类仍然是最智能的部分。但是未来当机械智能超过人类智能数亿、数十亿倍时，人类仍然可以是这个系统中唯一或者至少最有思感的部分。因为人类对于思感独一无二的能力（事实上，动物和昆虫同样有思感），我认为我们在这个新兴的超个体中扮演了一个重要的角色。我们就是它的感觉系统。因为最终我们才是观察、感觉以及了解它所想所做事情的人。
因为人类才是统一体所做所想的目击者和知情者，统一体的作用极可能是服务并充实人类，而不是取代人类。这将是一个人类和机器共同协作的系统，目的是为了人类的福祉而非机器的。这种未来愿想非常不同于有些人预想的“终结者式”未来，那些人认为未来机器会聪明到灭绝人类。不会发生那样的事。假如机器能变聪明的话，这也需要很长一段时间内，因为它们不会产生思感。我认为我们应该更应该担心人类毁灭人类自己而非机器。
现在转到凯文·凯利（Kevin Kelly）所说的第四层次——“一个具备思感的智能超个体”。我们必须把人类纳入该系统之内，单靠机器不会也不可能让我们达到那个层次。我不相信思感可以被制造，也不相信思感会突然出现在一个合适的复杂电脑系统中。我认为思感是宇宙的本质之一，而电脑程序却在这个本质数层之外。现在我们应该设计一种新的电脑架构，一个能更紧密联系量子场的架构。也许在这样一个系统中，像电流一样，思感才能够被包容。这只是一种可能性。这种系统极有可能更亲近自然，但是这只是个猜想。这是一个有趣的研究方向。
不管怎样，如果我们想要将人类纳入这个全球超个体——这个统一体、统一的机器体系之中，那么我们就已经处于Kevin Kelly所说的第四层次上了。如果我们不愿意这么做，那么我不认为你能马上进入第四层次，也许永远也不会了。
同样值得注意的是思感跟智能一样分许多层。有仅仅能感觉事物发生的基本的原始思感，也有更强大的思感，比如思感到自己存在的思感、拥有更高决策权的高度精确协调的思感、也有思感到物理本质存在的思感。思感具有和任何其他宇宙本质类似的空间性和虚无性。这些特点其实也是我们所生活在其中的量子本质所具有的。有趣的是这些特性也是现实的特性。佛教大家同样也称这些特性是现实和思维的最终本质。他们并不认为现实和思维是两种不同的事物。思感可能会也可能不会思感到思感和现实本身的这些特性。思感可以很简单、或者很低级、或者根本未觉醒。思感对宇宙本质的感知层次也是一种衡量其层次的方法。我们也称思感的这种能力为“解析度”。思感解析度越高，其对表象的真实本质、宇宙本质的感知也就越精确。当其解析度达到最高点时，思感可以直接认识其观察事物的类似空间、时间的量子本质。思感处于最高解析度时，观察者和被观察事物之间的二元性将消失：思感认知到一切事物都是思感在量子形式下存在的不同表现形式。
思感的另一个值得考虑的特点就是我们所说的“统一性”。在最低层次的统一性层面上，根本就没有统一性的概念，有的只是一些极其孤立或单一的个体。而在最高层面上，所有的事物都包含在了一个思感场中。这是一种完全的统一。这种最高阶级我们以“全知”称之。佛教关于精神启示的概念就是一种同时达到最高解析度和最高层次统一度的思感。
在我看来，全球超个体已经觉醒，但是它还没有达到高解析度或者高统一性。这是因为大部分人，以及大部分人类群体和组织本身仅仅只能达到最低层次上的思感觉醒。自从人类以及人类群体组成了全球超个体的思感，我们个人和集体的思感进化就和整个超个体的思感进化也就直接联系到了一起。这也是为什么个人以及群体提高自身思感重要的原因。思感在“这儿”作为宇宙本质的一个方面存在，但是和物质、能量一样，思感可以被引导、累积以及塑造。现在我们以及我们所在群体所展示出来的思感大多未开化或者有待发展。
在我们这个年轻现实、令人着迷的二元文明中，我们在思感上只取得了极小的进步。取而代之的是我们将大部分精力投入了宇宙的其他本质如空间、时间和能量方面的研究。我认为当一个文明对宇宙本质的思感的研究投入和对其他本质的研究相当时，如果不是更多的话，这个文明也就完全成熟了。这也是我们正在开始做的，多亏量子理论打破了我们经典物理学的桎梏并迫使我们承认思感也许在我们的现实世界中起了一些作用
有许多方法可以加速个人和整体的思感进化，这样做可以整体提高我们的文明水平。我最近一直再就这方面的具体情况进行阐述和写作。
在个人层次上，提升我们自身思感的一个方法就是通过冥想和精神升华。这是最重要也是最有效的方法。可能有许多技术提升方法，如增强现实和增强感知。它们可以在如何认知以及了解我们所认知事物的深度上帮助我们提升。在不久的将来我们也许可以有机会利用电脑或者生物方法来大幅提高我们感觉器官的广度和解析度。我们甚至可以进化出我们现在无法想象的新感觉。另外，以互联网为例，我们可以在一瞬间知道比以往任何时候都要多的事。但是最终，我们个人的思域将进入内省阶段以便真正获得更高的解析度和统一性。但是这些并不是可以真正提高我们思感的好方法。比如，如果我们可以使用机器去获得更多的信息，但是如果我们的思感仍处于一个相对低水平，那么我们究仍然不能整合或者利用这些信息。
众所周知，人脑屏蔽了大部分我们获取的信息。当使用迷幻药品时，大脑的过滤栅会张得更开，这样人们就能感觉到一些以前一直被屏蔽掉的事物。扩大思感广度，增加思感解析度和统一度的结果和吸毒时的感觉类似。除了前者效果更持久，并且可以通过日复一日的强化来控制和增效。我认识的许多西藏喇嘛似乎已经做到了这一点，他们的思域相当宽广，而且其对宇宙的见解也相当准确。他们似乎真的能看到事物的每个细节，甚至是那些最微小的事物，同时他们很少或者根本没有个体观念。个体观念的丧失反过来似乎为他们移除了一些特定的障碍，从而让他们能够感知一些原本超过他们思域感知以外的事情。例如，他们可以感知其他人的想法，预见一些发生在其他地方或时间段的事情。这都可能实现，因为他们思感的解析度和统一性提升了。
在整体层面上，同样也有方法能提升群体、组织以及社会的思感，特别是当我们能建立像“自我构建”作用于人一样作用于群体的系统时。
自我是虚像。这是个好消息。如果它不是虚像，那么我们永远也不会看透它，也不会获得精神启示。更重要的是，如果它不是虚像，我们就会幻想通过机器或者机器大集合来制造它。佛家、神经学家和认知学家似乎都同意“自我”是虚像这个事实。自我是虚像，它仅仅是一种精神构造。正确地运用它会非常有用。但是没有自我的观念，人类会难以交流，甚至会浑浑噩噩。同样，没有自我归属观念，组织机构和社会同样也无法有效地运行。
自我构建与自我模板、自身环境一道构成一体。这个模板包括发生在“内部”和“外部”的事，以及自我和“我”的观念。通过制造这种人为的界限和模式化发生在界限两边的事情，自我构建能够测量和规划行为的尺度，并能使一个系统改善和适应“自己”以及外部环境。具备自我构建能力的个体表现得远比那些不具备这种能能力的个体智能，想想人和狗的智能吧。在这两个物种之间在智能上的差距其实就是自我构建能力之间的差距。人类比狗更自觉、更自省也更成熟。它们都有思感，但是人类自我构建能力更高。这个道理对于简单的人工智能程序和诸如工作组、企业以及网络社区的集体智能同样适用。自我构建功能越成熟，其系统就越聪明。
合理而有效地运用自我架构的关键在于发展出一个健康的自我，而不是完全湮灭自我的存在。湮灭自我会造成一种虚无主义，从而导致个体无法在这个世界上生存。这可不是佛家或者神经学家提倡的了。那么怎样才算一个健康的自我呢？对于个人来说，一个健康的自我就是能表里如一地对过去、现在和预计好的未来有一个清晰的反映；高度自觉、理性但不自负，而应带着适应的尊敬的眼光看待外部世界和其他事物；思想开放、善于学习和为适应新环境而改变。这同样适用于一个健康的集体。但是，当今大部分人并没有一个健康的自我，他们有的是极度阴暗、不健康的自我。这反过来在更高层次上影响了我们建立的群体、组织和社会的自我构建。
现在我们能做的最重要的一件事就是,创造能为诸如群体、组织和社会等集体提供虚拟自我的系统。这些虚拟自我为这些集体提供镜子，从而让这些系统中的成员可以看见整体，以及他们在其中的适应情况。一旦看到这些，他们就能开始调整自己的行为以适应整体的发展方向。这个简单的反射功能能够促使其在自我管理上上一个新的台阶，并使原来混乱不堪的单个个体“群落”动作协调起来。
事实上，我认为集体的发展有三个阶段：
第一阶段：群落。在这种组织形式中，其组成个体并没有思感到整体的存在，对身份和目标也没有统一的概念。然而它也有思感的做某些事，例如，鱼群或者鸟群。它们没有首领，但是这些个体通过适应它们周围同类所做的事情，从而从整体上看起来像某种意义上的单体。群落形态就和一团以斑状外形存在的阿米巴实体一样。这和气体的物理模型没多大差别。
第二阶段：群体。群落的下一发展阶段就是群体了。群体的一些结构经常包含一个命令和控制系统。这中组织形态更严密。群体能够表现出更多的目的性和智能行为。家庭、城市、工作组、运动队、军队、大学、公司和国家等都是群体。大部分群体具备和低级动物相当的智能。他们可能具有身份和自我的概念，基于此，它们计划和行动显得更一致。
第三阶段：元个体。集体智能的最高阶段是元个体。这开始于曾经是群落中孤立的个体在根据自身特点进化为一个新个体时，一个成熟的元层面上的自我构建系统从整体考虑将其重新组合。这种进化成为元系统转化——不见通过变换组合后形成一个更高级的新整体。这个新整体重组了部件，但是改变了部件的功能。一个集体要进化成为真正的个体，它需要具备整体头脑和意志。最重要的是，它还必须形成高层次的集体思感。高层次集体思感的形成需要一个成熟的集体自我构建功能来作为催化剂。幸运的是，这是我们能够创建的，因为如之前所述，自我是虚像，是一种构造，因此自我能够被建造出来，即使对于包含数百万或者数十亿成员的大集体来说也是如此。
全球超个体已经被一群先见者称为“全球大脑”超过一个世纪。今天我们也许可以开始称它为“统一的机器体系”，或者统一体，或者其他名字。但是不管怎样，我认为我们能做的作重要的工作就是提供一个更高级更准确意义上的集体自我来让它变得更聪明了。为此我们也许应该让一些小得多集体如群落、团队、企业和在线社区发展起来更好的自我。我们能够指引并促进它们进入更高的集体思感和自我管理层面吗？我非常相信这是有可能的，我也肯定科技进步将支持这一目标的实现。
转载出处： How to Build the Global Mind http://www.novaspivack.com/uncategorized/how-to-build-the-global-mind</description></item><item><title>下个世纪，智能机器人会取代人类吗？</title><link>https://glows.github.io/_posts/%E4%B8%8B%E4%B8%AA%E4%B8%96%E7%BA%AA%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BC%9A%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%B1%BB%E5%90%97/</link><pubDate>Wed, 10 Jan 2018 17:19:44 +0000</pubDate><guid>https://glows.github.io/_posts/%E4%B8%8B%E4%B8%AA%E4%B8%96%E7%BA%AA%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BC%9A%E5%8F%96%E4%BB%A3%E4%BA%BA%E7%B1%BB%E5%90%97/</guid><description>(转载)凯文·凯利：下个世纪，智能机器人会取代人类吗？ 前几天是人工智能之父阿兰·图灵的100周年诞辰。考虑到纪念图灵的文章已经很多了，所以本周俺转载几篇人工智能相关的文章。 下面这篇出自IT界预言帝凯文·凯利。他任主编的《全球概览》杂志让乔布斯推崇备至（乔布斯的名言“Stay Hungry Stay Foolish”就是从该杂志看来滴）；他创办的《连线》杂志在全球IT界举足轻重。
================华丽的分割线================
2000年4月，道格拉斯·霍夫斯塔特（Douglas Hofstadter）在斯坦福大学组织会议，讨论这个问题：“2100年智能机器人将取代人类吗？”与会者有比尔·乔伊（Bill Joy）、雷·库兹维尔（Ray Kurzweil）、汉斯·莫拉维克（Hans Moravec）、约翰·霍兰德（John Holland）和我。这是个严肃的问题。
我决定通过分析问题中的每个词来回答这个问题。
2100
我发现，尤其是在回顾有关科技的长期历史时，以人类的世代为标准大有好处。我粗略估算每25年为一代。文明开始于一万年前——最古老的城市耶利哥诞生于公元前8000年，它创造的文明如今在耶利哥和世界其它地区延续了约400代。那是400个由母亲到女儿的生育周期。文明人类的400代并不很长。如果没有别的事情可做，我们几乎可以背熟400个周期所有的名字。400代之后，我们已经成为不同于初期的人类。大约在8代之前，我们才有自动装置和机器人的概念，在两代之前才制造出第一部电子计算机。整个万维网的诞生还不到2000天！按同样的人类寿命计算，距离2100年只有四代。如果我们在2100年转变为机器人，那么文明的人类将仅延续400代。那将是生命历史上一个物种最短的寿命。
人类
在即将到来的世纪，核心问题（即主要问题）不是“人工智能是什么？”，而是“人类是什么？”人类有什么用？我预测，在即将到来的世纪，各种有关“人类是什么”的问题将成为《今日美国》之类报纸经常用到的标题。电影、小说、会议和网站都将设法解决这个核心问题，“我们是谁？人类是什么？”在长期繁荣的经济发展支持下，一切皆有可能，一切皆不确定，我们将遇到更多有关自己身份的问题，而不是这些问题的答案。我们是谁？男性或女性，父亲、美国人或人类是什么意思？下个世纪有可能被形容为大规模、全球范围的百年身份危机。到2100年，人们会为回溯到今天的我们人类感到惊奇，因为我们竟然知道人类是什么。
取代
取代在自然界很罕见。我们现在之所以拥有二百万个物种，正是因为大多数新物种并不会取代老物种，它们宁愿与现有的生物体交织起来，挤进小生境之间，以其它物种的成就为基础。创立一个新的小生境远比取代已被占居的小生境容易得多。大多数物种的灭绝不是因为有篡位者，而是因为其它因素，如气候变化、彗星或其自身造成的麻烦。取代或淘汰人类似乎不可能。假如我们不知道人类是什么，我们的角色就可能会改变，我们更有可能重新定义自己，而不是消失。
机器人
一般而言，我喜欢汉斯·莫拉维克（Hans Moravec）的确切阐述：这些机器人是我们的孩子。如何养育孩子？我们培养他们必然是为了放手。如果我们的孩子永远不离开我们的控制，我们不只会失望，而且会变得残忍。为了创新，为了富有想象力、创造力和自由，孩子需要脱离其制造者的控制。我们心目中的孩子——机器人也一样。一个家长，有一个得不到关心的孩子，他会一点都不担心吗？我们花了很长时间才认识到，科技的力量与其固有的失控及其固有的令人惊喜且具有生产力的能力成比例。事实上，除非我们不能再为科技操心，它的创新就没有尽头。强大的科技需要责任心。由于机器人具有繁殖能力，我们需要更强大的责任心。我们应该有目的地培养我们的机器人孩子成为好公民。也就是说，要逐渐为他们灌输价值观，以便在我们放开手时，他们能够作出负责任的决定。
智能
我们能够想象的最智慧的事情是什么？与一个外星人进行可验证的接触将动摇国教的基础。无论外星人给出的答案是什么，都将重新提出有关上帝的问题。我认为《接触》是唯一一部使神学者成为明星的影片。我们不必等待外星智能探索项目与外星人接触。我们将通过制造外星人，也就是说通过制造机器人来完成这个任务。这样一来，外星人就有了另一个名字：人工智能。担心人工智能成为人造人类的人大错而特错。人工智能将更接近于人工外星人。你的计算机在算法上已经比这个房间里任何人都更聪明了。为什么我们并没有因此而感到威胁？因为它是“另类”，是一种不同的智能，是比我们高级，而我们并不会特别妒忌的智能。我们创造的智能，包括最聪明的人工智能，大多数将成为“另类”。实际上，在各种有意识智能的可能空间，可能存在着两百万种其它智能物种，而不只是我们所知的一种（人类）——它们每一种都像计算机和海豚一样，是独特的、不同的。我们没有理由去克隆一个人类智能，因为制造传统版本的人类非常容易。在即将到来的世纪，我们要做的努力就是利用迄今为止所有的智能（人造的和自然的）创造所有可能的新智能。我认为迎接我想到的这些智能将是我们目前所能想象的最智慧的事情。
会取代
我认为，科技有自己的日程表。我问自己的问题是，科技想要什么？概括地讲，如果说科技是个孩子，甚至是个青少年，能了解青少年想要什么确实有益。我们称为“科技”的这个系统，它的先天欲望、固有偏爱、内在驱动力是什么？一旦知道科技想要什么，我们就不必对所有这些需求让步，不必超过你所放任的青春期孩子的任何欲望，不过，你也不可能完全拒绝这些需求。科技“会”希望这些事情发生吗？我认为，它们希望其发生。我们所了解的科技是，它想更小（摩尔定律），它想更快（库茨维尔定理），我猜，科技想做人类所做的任何事情（凯利定律）。我们人类发现了其它生物的巨大价值，并逐渐发现其它智能的巨大价值。我认为，机器人没有理由发现不了人类也同样有价值。机器人能够，或者想要做一切人类所做的事吗？不，通常我们会让它们做我们不愿做的事。那么之后，我们人类做什么呢？机器人将第一次赋予我们力量说：我们想做的任何事。
转载出处： Will Spiritual Robots Replace Humanity by 2100? http://www.kk.org/thetechnium/archives/2006/03/will_spiritual.php</description></item><item><title>比尔·乔伊：为什么未来不需要我们人类</title><link>https://glows.github.io/_posts/%E6%AF%94%E5%B0%94%E4%B9%94%E4%BC%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%AA%E6%9D%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E4%BA%BA%E7%B1%BB/</link><pubDate>Wed, 10 Jan 2018 17:14:31 +0000</pubDate><guid>https://glows.github.io/_posts/%E6%AF%94%E5%B0%94%E4%B9%94%E4%BC%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%AA%E6%9D%A5%E4%B8%8D%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E4%BA%BA%E7%B1%BB/</guid><description>(转载)为什么未来不需要我们人类 比尔·乔伊 在21世纪，我们威力无比的三种科技：机器人、基因工程和纳米技术正在使人类成为濒危物种。
自从我从事科技创造的那一刻起，我就关注其在伦理上的问题。但直到1998年秋天我才认识到我们在21世纪面临着多大的危险。这一不安始于我遇到雷·库兹维尔（Ray Kurzweil），一位伟大的发明家，发明了为盲人服务的阅读机，还有许多不可思议的机器。
我和雷（Ray Kurzweil）都是在佐治亚州Gilder市召开的远程通讯大会的发言者。会议结束后，我在旅店酒吧与他偶遇。当时我正在与约翰（John Searle），一位在加州大学佰克利分校研究意识问题的哲学家，坐在一起聊天。雷（Ray Kurzweil）走过来与我们攀谈起来。直至今日，我们谈论的内容依然困扰着我。
我没有听到雷（Ray Kurzweil）的演讲及其后来的座谈，而约翰（John Searle）有，他们现在重拾未完的话题。雷（Ray Kurzweil）认为技术进步的速度将会越来越快，我们将会成为机器人或者与机器人结合的合成人，或者与之类似的东西。但约翰不以为然，他认为这不可能发生，因为机器人不会有意识。
在听到这样的谈话之前，我一直认为有感觉的机器人只存在于科幻小说中。但现在，从一些值得尊重的人那里，我知道了那些机器人已经离我们不远了。我大吃一惊，特别是我知道雷（Ray Kurzweil）已经证明自己有资格有能力描绘并创造出这一未来。我现在已经知道新科技，比如基因工程、纳米技术，能帮助我们重新改造这个世界，但智能机器人的现状与未来使我感到惊奇。
诸如此类的技术突破会使人厌倦。我们几乎每天都能听到关于科技进步的新闻。但这次可不是一般的预言。在旅店的酒吧里，雷（Ray Kurzweil）给了我一本他即将出版的新书《智能机器的时代》的预印本。他在这本书中勾勒出了他心目中的乌托邦：通过机器人技术，人类将会得到几乎永生不灭的生命。在阅读这本书时，我心中的不安越来越强烈。我敢肯定，雷（Ray Kurzweil）低估了机器人技术的危险性，低估了这一技术造成严重后果的可能性。
我发现以下反乌托邦情景让自己寝食难安：
新卢德主义的挑战
首先让我们假定计算机科学家开发出了比人类更能干的智能机器。在这种情况下，所有的工作将由大量组织良好的机器系统完成，而人类不再需要进行劳动。我们可能会充许机器自主地作出决定，或者人们依然保留对机器的控制。这两种情况都有可能发生。
如果允许机器自主运行，由于我们不可能猜测出机器是如何得出结论的，所以也就无法推测这一结果。我们将会发现人类的命运将掌握在机器手中。也许有人会争论说人类不会愚蠢到把所有的权力移交给机器，但我们正在谈论的既不是人类把权力让度给机器，也不是机器有意攫取权力。我们谈论的是人类很容易陷入不得不接受机器的自主决定，从而依赖机器生存的境地。随着社会及其面对的问题越来越复杂，并且机器的智能越来越高，人类将让机器作出越来越重要的决定，不为其他，只是机器作出的决定要比人类明智得多。最终，由于保持系统正常运行的决策是如此复杂，人类的智能再也无法承担，而机器却能胜任愉快。人们再也无法简单地拨掉机器的电源，因为我们是如此依赖机器，关机无异于自杀！
另一方面，人类保持对机器的控制是有可能的。比如，在上面所说的情况下，相当部分的人仍然控制私人拥有的机器，象汽车、个人电脑之类。但控制大型机器系统的是极少数精英阶层，就象当今社会一样。但与现在相比有两点不同：由于科技进步，精英阶层对广大群众有了更大的控制权，并且由于人类劳动不再是必需的，广大群众也变成了整个系统无用而多余的负担。如果精英阶层是冷酷无情的，他们可能会简单地把这些人消灭殆尽。如果他们是仁慈的，可能会用宣传或其他精神上、生物上的技术来降低人口出生率，直至这些人灭绝，从而完全拥有这个世界。还有另外一种可能性，如果精英阶层是软心肠的自由主义者，他们可能会扮演牧羊人的角色来照顾其余的人类。他们将会满足每个人肉体上的需要，让孩子们健康地成长，每个人都会忙于有益身心健康的爱好，任何对此不满意的人都会受到“特殊照顾”以纠正他们的“问题”。当然，生命是如此没有意义，以至人们不得不接受生物或精神上的改造以去除他们对权力的欲望，或者使之“升华”成无害的嗜好。这些经过改造的人类在这样的社会中也许会感到快乐，但他们肯定是不自由的，他们就像动物园中被饲养的动物。
直到你读到这一页，你才发现以上内容的作者是是荻尔多·卡辛斯基，著名的“大学炸弹客”。我并不是卡辛斯基的辩护者。在他17年的恐怖活动中，用炸弹夺走了3个人的生命，还炸伤了很多人。其中一枚炸弹使我的朋友DavidGelernter严重受伤，戴维是我们这个时代最具天才与想象力的计算机科学家。就象我的很多同事一样，我感到我很有可能就是“大学炸弹客”的下一个袭击目标。
卡辛斯基的行为是谋杀和愚蠢的罪行，毫无疑问，在我眼中他是个卢德主义者，但简单地下此结论难以驳倒他的观点。虽然很难，但在上面一段论述中，我还是察觉到了一些真相，我感到我有责任来面对它。
我们不希望卡辛斯基想象的反乌托邦成为现实，但一个众所周知的关于设计与技术应用的问题可以用“墨菲定律”来描述：“会出错的，终将会出错”（事实上，应当称之为菲纳络定律，这一错误本身就证明了菲格纳真是英明无比！）抗生素的过度使用已经造成最严重的问题：抗生素耐药性危机和越来越多的危险细菌。与之类似的事情曾经发生过：想用DDT杀死传播虐疾的蚊子，却使之产生DDT耐药性，其幼虫也获得了对多种药物的耐药性基因。
诸如此类令人惊奇的事故清楚地表明：系统各部分相互之间的作用与反馈太过复杂，对系统的改变会引起连锁反应，难以预料最终结果。特别是把人类的活动也考虑进来后，情况就越发复杂了。
我开始向朋友们介绍《智能机器的时代》一书对对卡辛斯基言论的引用；我递给他们卡辛斯基的书，让他们阅读这些引文，然后观察当他们发现是谁写下这些文字时的反应。大约在这一段时间，我发现了汉斯·莫拉维克（Hans Moravec）的《机器人：通往非凡思维的纯粹机器》。莫拉维克是机器人研究领域的领军人物，他在卡耐基·梅隆大学创立并领导着世界上最大的机器人研究计划。这本书给了我更多的材料来考验我的朋友们。令人惊奇的是，那些材料大多支持卡辛斯基的论调。例如：
“近期（2000年早期）”一章
生物物种在遭遇到占优势的竞争者时几乎毫无生存的机会。一千万年以前，南北美洲被巴拿马地峡分开。南美洲就象今天的澳大利亚，到处繁衍着有袋类哺乳动物，有袋鼠、袋鹿和袋虎等等。当连接南北美洲的地峡升起后，北方在新陈代谢与神经系统上只占很少优势的胎生物种只用了几千年的时间就替换并灭绝了几乎所有的南方有袋类物种。
在完全自由竞争的市场上，占优势的机器人就会象北美胎生物种影响有南美有袋类物种一样影响人类的生存（也好象人类曾经影响无数其他物种一样）。机器人工业将会为了原材料、能源和空间展开激烈的竞争，其结果就是机器人的经济性超过人类。由于无法负担生活所需，人类将会被排挤出生存空间。
可能还有可能给人类留下喘息的空间，因为我们并不是生活在一个完全自由竞争的市场中。政府会强制执行一些非市场化政策，特别是税收。通过这一明智之举，政府的强制措施能支持人类在机器人劳动成果的基础以一种较高的生存状态繁衍生息。这一情况可能会持续很长时间。
这真是一本反乌托邦的生动教材，并且会让莫拉维克感到很不舒服。他继续讨论我们在21世纪的主要是：“制定法律来规范机器人工业的行为，确保与其持续的合作”。并描述了“一旦人类转变为毫无约束的超级智能机器人”会产生多么严重危险。在莫洛维克的观点里，机器人最终会战胜我们，人类毫无疑问将面结灭绝的命运。
我决定在此时此刻与我的朋友丹尼·希里斯（Dany Hillis）好好谈一谈。丹尼是生产并行超级计算机的Thinking Machines公司的创始人之一。我不光是太阳微系统公司的首席科学家，同时也是一个计算机设计者。丹尼在信息和物理科学方面的知识超过我认识的每一个人。丹尼还是一位值得关注的未来学家，他对未来进行了很长时间的思考，并在四年前创立了Long Now Foundation，他还为过去10000年制造了一台时钟，尝试刻画出人类历史上值得纪念的时间段（见“Test of Time”《时间测试》，《连线》2003年8月78页）。
因此我飞到洛杉矶与丹尼夫妇共进午餐。我倾其所有，向丹尼提出了一些困扰我的想法我思路供其考虑。丹尼的回答直指库兹维尔（Ray Kurzweil）设想的未来情景：人类与机器人合二为一的时代很快就会到来。这一回答令我大吃一惊。总而言之，他认为这一变化会逐渐成为现实，人们迟早对此会习以为常。
但我认为我没有完全地感到惊奇。我从丹尼那听到了对库兹维尔（Ray Kurzweil）书中内容的引用。他说：“虽然我象别人一样喜爱自己身体，但是如果我能依靠硅基肉体活上200岁，我会毫不犹豫地放弃它。”看上去丹尼已经对一变化过程及随之而来的危险听天由命了，而我却不能。
当谈论与思考关于库兹维尔（Ray Kurzweil）、卡辛斯基及莫拉维克（Hans Moravec）的事情时，我突然想到了20多年前读过的一本弗兰克·赫伯特（Frank Herbert）的科幻小说《白色瘟役》（The White Plague）。在小说中，一位分子生物学家因其父母妻儿被无原无故地谋杀而陷入疯狂。为了报复，他制造并散布了一种新研制的高度传染性的瘟役，用它来杀死很多经过选择的人（我们应当庆辛卡辛斯基只是个数学家，而不是分子生物学家）。我还记得《星际迷航》（Star Trek）中的博格人（Berg），一种具有毁灭倾向的半人半机械生物。类似博格人的灾难是科幻小说中经常出现的情节。这就是我为什么更早更关注这样的机器人反乌托邦的原因。为什么其他人不为这梦魇般的未来世界操一点心呢？
这一问题的部分答案在于我们偏狭的劣根性：喜欢新奇的东西、马上就能上手的东西、毫无诫心地接受它们。习惯于每天听到的科技新发现。我们已经处于这样一个阶段：21世纪最引人注目的科技：机器人、基因工程和纳米技术，在其到来之前就已经表面出了与众不同的巨大威力，特别是机器人、经过基因工程改造过的有机体、纳米技术具有相同的使危险扩大的因素：它们能自我复制。一枚炸弹只能响一声，但一个机器人能就自我复制成很多个，很快就会失去控制。
在过去25年中，我的大部分工作是计算机网络研究。在网络上发送与接收信息会造成失控复制。虽然计算机或计算机网络上的失控复制很讨厌，但是在最坏情况下也不过是使单台计算机无法正常工作或阻塞网络通讯、网络服务。而那些更新科技产品的失控自我复制会造成更大危险：它们会损害到物理世界。
这些科技都提出了数不清的美好承诺：库茨维尔在其机器人梦想中看到的近乎长生不老的前景激励我们不断前进，基因工程很快就能为大多数不能很快痊愈的疾病提供了治疗方法；纳米技术和纳米医疗能治愈更多疾病。所有这一切将会极大提高我们的平均寿命及生活质量。然而，对于其中任何一项技术，持续不断地微小、个别的进行会积累成威力巨大的力量及其伴随而来的巨大的危险。
20世纪有何与众不同？当然，产生大规模杀伤性武器（WMD）核武器、生物武器、化学武器的科技极具威力，并且这些武器具有巨大的威胁性。但建造核武器至少需要时间、稀少、事实上不可能得到的原材料以及高度保密的资料；生物武器和化学武器的研制也需要开展大规模的活动。
而21世纪的技术——基因工程、纳米技术和机器人（GNR）的威力是如此巨大，它们会孕育出新的事故及滥用方式。最危险的是，这些事故与滥用首先会在个人或小型组织就能企及的能力范围内。它们不需要巨大的开发能力或稀少的原材料，只要有相关技术知识就能利用它们。
因此，我们不光受到大规模杀伤性武器的威胁，还有技术知识产生的大规模杀伤力，它们的自我复制能力极大地扩展了其杀伤力。
我想以下所说绝对不是危言耸听：我们人类面临产生极端邪恶的最高可能性，这一邪恶的产生正由国家力量支持的大规模杀伤性武器转而到恐怖的极端个人。
没有什么指出我们将面对这样的问题。
我的生命被内心深处的热情驱使着提出问题、找寻答案。当我3岁时，我已经开始阅读，所以我的父亲把我送进了小学，我那时只能坐在校长的腿上听他讲故事。我很早就开始上学。然后跳级，我以难于置信的热情投入到书本之中进行学习。我提出了很多让大人们都很难解决的问题。
作为一个十多岁的少年，我对科技技术非常着迷。我希望成为一名“火腿”（业余无线电爱好者），但我没有钱买设备。“火腿”是那个时代的因特网，非常容易上瘾，也使人离群索居。暂且不论有没有钱，我母亲马上表示坚决反对，我不能成为一名“火腿”，因为我已经够孤僻的啦！
那时我没有什么亲密的朋友，但我沉醉在我丰富的想像之中。我中学时代，我发现了许多伟大的科幻小说家。特别是我仍然记得Heinleain的《穿着太空服去旅行》（Have Spacesuit with Travel）和阿西莫夫的《我，机器人》及其机器人三原则。我被关于太空旅行的描写深深迷住了，就想拥有一架望远镜来看一看天上的星星；由于我没有钱买或制作一架，我就从图书馆借来关于如何制造望远镜的书，通过阅读来安慰自己。我在想像的空间中自由翱翔。
星期四晚上我的父母会出去打保龄球。而我们这些小孩独自待在家中。星期四晚上是吉恩·罗顿巴里（Gene Roddenberry）最初的《星际迷航》（Star Trek）播出的时间，这个节目给我留下了深刻的映象。我开始接受这样一种理念：人类未来将在太空进行西部英雄式的冒险。罗顿巴里描绘的几个世纪后的情景有着重要的道德价值：遵守“第一守则”，不要干预任何技术水平较低的文明的发展。这些对我有着不可否认的吸引力；是精英人类，而不是机器人会支配我们的未来。罗顿巴里梦想成为我生命中不可或缺的一部分。
最脍炙人口的电视科幻片集《星空奇遇》，其中述及太空合众国的所有探险队都要遵守一条「第一守则」（prime directive），那就是。在未调查清楚及未得太空合众国批准前，不得干预任何文化水平较低的族类的自然发展。</description></item><item><title>Node.js Web开发</title><link>https://glows.github.io/_posts/node-js-web%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 25 Dec 2017 16:58:28 +0000</pubDate><guid>https://glows.github.io/_posts/node-js-web%E5%BC%80%E5%8F%91/</guid><description>概览 Node.js Express mongoDB jQuery Semantic UI Visual Code Google 功能需求 首页文章显示 注册登录功能 文章编辑发表 评论 文章删除 一、 创建项目，执行如下代码：
npm init 1、新建 index.js 作为项目入口文件， 使用MVC架构。
引入框架和组件，添加中间件（如connect-flash、） 设置模板目录设置模板引擎为 ejs
2、创建路由文件夹 &amp;ldquo;routes&amp;rdquo; 和文件 &amp;ldquo;/routes/index.js&amp;rdquo;, 核心代码编辑如下：
module.exports = function (app) { app.get('/', (req, res) =&amp;gt; { res.send(&amp;quot;hello, express&amp;quot;); }) app.use('/posts', require('./posts')); // routes文件夹下 模块路由 app.use(function(req, res){ if(!res.headerSent){ res.render('404'); } }); }; 模块路由代码示例：
// GET /posts 所有用户或者特定用户的文章页 // eg: GET /posts?author=xxx router.</description></item><item><title>react-native-初探</title><link>https://glows.github.io/_posts/react-native-%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 25 Dec 2017 16:46:00 +0000</pubDate><guid>https://glows.github.io/_posts/react-native-%E5%88%9D%E6%8E%A2/</guid><description>环境搭建 -Android开发环境 / MacOS Xcode 开发环境 -Node.js -npm -react native -编辑器 Visual Code
包依赖 基本：
react react-native
导航： react-navigation
Api获取： jsonwebtoken 运行项目 在此就默认 Android开发环境 / MacOS Xcode 开发环境 已搭建完成，继续执行下面的命令
react-native init myProject 测试安装
react-native init AwesomeProject cd AwesomeProject react-native run-android 写一个“hello world”&amp;mdash;-
import React, { Component } from 'react'; import { Text } from 'react-native'; export default class HelloWorldApp extends Component { render() { return ( &amp;lt;Text&amp;gt;Hello world!&amp;lt;/Text&amp;gt; ); } }</description></item><item><title>learning</title><link>https://glows.github.io/_posts/learning/</link><pubDate>Mon, 25 Dec 2017 16:14:32 +0000</pubDate><guid>https://glows.github.io/_posts/learning/</guid><description>Learning Hey, Wake up!
许多人所谓的成熟，不过是被习俗磨去了棱角，变得世故而实际了；那不是成熟，而是精神的早衰和个性的夭亡！ 真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。 ——《在世纪的转折点上》尼采（哲学家）
你要看一个国家的文明，只需考察三件事： 第一，看他们怎样待小孩子 第二，看他们怎样待女人 第三，看他们怎样利用闲暇的时间 ——胡适 （思想家）
好的程序员是那种过单行道马路都要往两边看的人 ——Doug Linder
你要按你所想的去生活 否则你迟早会按你所生活的去想
没有投票权的征税就是暴政 ——詹姆斯.奥蒂斯 （美国独立时期评论家）
大多数人在20到30岁就已经过完自己的一生； 一过了这个年龄段，他们就变成自己的影子，以后的生命只是在不断重复自己&amp;hellip; ——《约翰.克里斯朵夫》罗曼.罗兰</description></item><item><title>vue项目下vuex的配置</title><link>https://glows.github.io/_posts/vue%E9%A1%B9%E7%9B%AE%E4%B8%8Bvuex%E7%9A%84%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 29 Nov 2017 10:14:06 +0000</pubDate><guid>https://glows.github.io/_posts/vue%E9%A1%B9%E7%9B%AE%E4%B8%8Bvuex%E7%9A%84%E9%85%8D%E7%BD%AE/</guid><description>首先成功运行vue-cli项目
安装vuex
npm instal i vuex &amp;ndash;save 修改配置文件
store
新建文件夹store（与router同级） 然后在store目录下新建index.js
import Vue from &amp;#39;vue&amp;#39;; import Vuex from &amp;#39;vuex&amp;#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: process.env.NODE_ENV !== &amp;#39;production&amp;#39;, modules: { }, getters: { }, actions: { }, }); main.js
import Vue from &amp;#39;vue&amp;#39; import router from &amp;#39;./router&amp;#39; import store from &amp;#39;./store&amp;#39; Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ router, store }).$mount(&amp;#39;#app&amp;#39;) index.html
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;vue-cli&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</description></item><item><title>jQuery</title><link>https://glows.github.io/_posts/jquery/</link><pubDate>Tue, 24 May 2016 14:39:45 +0000</pubDate><guid>https://glows.github.io/_posts/jquery/</guid><description>了解jQuery 是什么: What? 一个JS函数库: write less, do more 封装简化DOM操作(CRUD) / Ajax 为什么用它: why? 强大选择器: 方便快速查找DOM元素 隐式遍历(迭代): 一次操作多个元素 读写合一: 读数据/写数据用的是一个函数 链式调用: 可以通过.不断调用jQuery对象的方法 事件处理 DOM操作(CUD) 样式操作 动画 浏览器兼容 如何使用: How? 引入jQuery库 本地引入与CDN远程引入 测试版与生产版(压缩版) 使用jQuery 使用jQuery函数: $/jQuery 使用jQuery对象: $xxx(执行$()得到的) jQuery的2把利器 jQuery函数: $/jQuery jQuery向外暴露的就是jQuery函数, 可以直接使用 当成一般函数使用人: $(param) param是function: 相当于window.onload = function(文档加载完成的监听) param是选择器字符串: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象 param是DOM元素: 将DOM元素对象包装为jQuery对象返回 $(this) param是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回 当成对象使用: $.</description></item></channel></rss>