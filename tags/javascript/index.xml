<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on Glow's Blog</title><link>https://glows.github.io/tags/javascript/</link><description>Recent content in javascript on Glow's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>glows</copyright><lastBuildDate>Wed, 19 Aug 2020 10:03:07 +0000</lastBuildDate><atom:link href="https://glows.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>WebSocket 使用</title><link>https://glows.github.io/_posts/2020-8-19-websocket-%E5%B0%81%E8%A3%85/</link><pubDate>Wed, 19 Aug 2020 10:03:07 +0000</pubDate><guid>https://glows.github.io/_posts/2020-8-19-websocket-%E5%B0%81%E8%A3%85/</guid><description>WebSocket 封装 WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。
WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。
WebSocket协议规范将ws（WebSocket）和wss（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。
let websock = null let messageCallback = null // callback message important !!!! let errorCallback = null let wsUrl = &amp;#39;&amp;#39; // 接收ws后端返回的数据 function websocketonmessage (e) { messageCallback(JSON.parse(e.data)) } /** * 发起websocket连接 * @param {Object} agentData 需要向后台传递的参数数据 */ function websocketSend (agentData) { // 加延迟是为了尽量让ws连接状态变为OPEN setTimeout(() =&amp;gt; { // 添加状态判断，当为OPEN时，发送消息 if (websock.readyState === websock.OPEN) { // websock.OPEN = 1 // 发给后端的数据需要字符串化 websock.</description></item><item><title>常见数据结构</title><link>https://glows.github.io/_posts/2020-4-15-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 15 Apr 2020 14:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/2020-4-15-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>回到最初，计算机科学
基础学科内容，比如：网络知识、数据结构算法 编程思想
时间复杂度
常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。
栈 栈是一种LIFO(Last-In-First-Out，后进先出)的 数据结构
class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } peek() { return this.stack[this.getCount() - 1] } getCount() { return this.stack.length } isEmpty() { return this.getCount() === 0 } } 队列 队列数据结构的访问 规则是FIFO(First-In-First-Out，先进先出)。
this.stack.push(item) this.stack.shift() //移除数组中的第一个项并返回该项 链表 单向链表
class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度 this.</description></item><item><title>React-Hooks 指南</title><link>https://glows.github.io/_posts/2020-2-12-%E5%AD%A6%E4%BC%9Areact-hooks/</link><pubDate>Wed, 12 Feb 2020 10:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/2020-2-12-%E5%AD%A6%E4%BC%9Areact-hooks/</guid><description>React Hooks 含义 为函数组件提供钩子以实现外部功能，如添加状态
React 默认提供的四个最常用的钩子 useState() //状态 useEffect() //函数副作用 useContext() useReducer() 更多的 Hook包括 useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue 自定义Hook useImperativeHandle Typescript中搭配useImperativeHandle 和 forwardRef使用
export interface MyInputHandles { focus(): void; } const MyInput: RefForwardingComponent&amp;lt;MyInputHandles, MyInputProps&amp;gt; = ( props, ref ) =&amp;gt; { const inputRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); useImperativeHandle(ref, () =&amp;gt; ({ focus: () =&amp;gt; { if (inputRef.current) { inputRef.current.focus(); } }, })); return &amp;lt;input {...props} ref={inputRef} /&amp;gt;; }; export default forwardRef(MyInput); 建议useImperativeHandle和forwardRef同时使用，减少暴露给父组件的属性，避免使用 ref 这样的命令式代码 import { useRef,forwardRef,MutableRefObject,useImperativeHandle,Ref} from &amp;ldquo;react&amp;rdquo;;</description></item><item><title>JavaScript模块规范 --- Commonjs、AMD、CMD、es6 modules</title><link>https://glows.github.io/_posts/javascript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-commonjsamdcmdes6-modules/</link><pubDate>Thu, 24 May 2018 10:37:24 +0000</pubDate><guid>https://glows.github.io/_posts/javascript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83-commonjsamdcmdes6-modules/</guid><description>&lt;p>关键词: import require javascript module&lt;/p></description></item><item><title>reactjs&amp;redux一些问题</title><link>https://glows.github.io/_posts/reactjsredux%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 17 May 2018 11:12:16 +0000</pubDate><guid>https://glows.github.io/_posts/reactjsredux%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid><description>&lt;h2 id="reactjsredux一些问题">reactjs&amp;amp;redux一些问题&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>缩进貌似会引起编译出错,遇到一次,不明觉厉;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>html文本中不能有&amp;lt;,&amp;gt;这种字符,如果需要用,需要用html编码替代;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有的React.createClass组件,命名时首字母要大写,不然会识别为一个标签而不是组件;&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Javascript基础数据结构</title><link>https://glows.github.io/_posts/javascript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 30 Jan 2018 10:41:47 +0000</pubDate><guid>https://glows.github.io/_posts/javascript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>数据结构和类型 JavaScript语言可以识别下面 7 种不同类型的值：
六种 原型 数据类型: Boolean. 布尔值，true 和 false. null. 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。 undefined. 变量未定义时的属性。 Number. 表示数字，例如： 42 或者 3.14159。 String. 表示字符串，例如：&amp;ldquo;Howdy&amp;rdquo; Symbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。 以及 Object 对象 仅凭这些为数不多的数据类型，你就可以在你的应用程序中执行有用的功能。
Objects 和 functions 是本语言的其他两个基本要素。你可以将对象视为存放值的命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。</description></item><item><title>开发中遇到的问题记录</title><link>https://glows.github.io/_posts/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 22 Jan 2018 15:12:38 +0000</pubDate><guid>https://glows.github.io/_posts/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>开发中遇到的问题记录 js去重(基本数组 与 对象那个数组) var unique = {}; obarr = [ {name: &amp;#39;sdsd&amp;#39;,key: &amp;#39;zc&amp;#39;} ] obarr.forEach(function(gpa) { unique[JSON.stringify(gpa)] = gpa }); obarr = Object.keys(unique).map(function(u) { return JSON.parse(u) }); POST application/json 适用于传递多层的json 本来以为自己写了那么多post请求，ajax已经难不住了呢， 结果现实无比的残酷， 后台换成了java，发多层级的json，后台就取不到了， 虽然到最后还是配置正确了，。。记录下来，引以为戒，
axios.post(&amp;#34;POST&amp;#34;, &amp;#34;/URL&amp;#34;, this.state.datas, {headers: {&amp;#34;Content-Type&amp;#34;: &amp;#34;application/json&amp;#34;}}) .then( res =&amp;gt; { console.log(res.data) }) .catch(err =&amp;gt; { console.log(err) }) // 来一个原生版的 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;amp;&amp;amp; xhr.</description></item><item><title>react-native-初探</title><link>https://glows.github.io/_posts/react-native-%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 25 Dec 2017 16:46:00 +0000</pubDate><guid>https://glows.github.io/_posts/react-native-%E5%88%9D%E6%8E%A2/</guid><description>环境搭建 -Android开发环境 / MacOS Xcode 开发环境 -Node.js -npm -react native -编辑器 Visual Code
包依赖 基本：
react react-native
导航： react-navigation
Api获取： jsonwebtoken 运行项目 在此就默认 Android开发环境 / MacOS Xcode 开发环境 已搭建完成，继续执行下面的命令
react-native init myProject 测试安装
react-native init AwesomeProject cd AwesomeProject react-native run-android 写一个“hello world”&amp;mdash;-
import React, { Component } from 'react'; import { Text } from 'react-native'; export default class HelloWorldApp extends Component { render() { return ( &amp;lt;Text&amp;gt;Hello world!&amp;lt;/Text&amp;gt; ); } }</description></item></channel></rss>